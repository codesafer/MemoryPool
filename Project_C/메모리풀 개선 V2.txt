/*----------------------------------------------------------------
	V1->V2 주요 변경점
		실행중, 물리적 메모리 절약을 위해 VirtualFree 사용
		기타 기능 추가
		※ 기록은 시간순으로 작성
----------------------------------------------------------------*/
★★★★
할당자의 확장처리(자동)시, 다음 상황임을 염두에 둔다
	확장요청은 사용자의 alloc 요청에 의해,
	MemoryBasekt 에서 대리로 메모리 Get 처리중,
	가용 메모리 유닛을 가진 유닛 그룹이 없어,
	할당자에 확장을 요청한 상태.
	이때 OS에 의해 할당된후 분배되어 나누어진 n개의 유닛 그룹들중 하나는
	확장을 요청한 스레드에게 우선 분배되어야 한다

	-> 확장 요청시, 확장을 요청한 스레드의 MemoryBasket의 주소를
	예약함을 알리기 위해 남긴다
	이 표식은 allocator 를 잠근 스레드의 사용만이 유효하다
	Allocator에서 확장후 호출한 keeping 매소드에서
	이 표식에 주소가 있다면 그것이 가르키는 MemoryBasket에
	우선적으로 유닛그룹중 하나를 배정한다
	이때 MemoryBasket 에 연결된 유닛그룹이 있는지 체크 할것인가?
	(확장성을 위해 방어적으로?)
	(체크하는 비용은 값싸다. 해당 MemoryBasket 은 캐시에 on 되어 있는 상태이기 때문에)
-> 완료
//----------------------------------------------------------------
★
	다음의 테스트는 CMemoryPool 에서 하던 것들인데,
	관리자에서 한번만 하도록 수정할것

        const UTIL::ISystem_Information* pSys = CORE::g_instance_CORE.mFN_Get_System_Information();
        const SYSTEM_INFO* pInfo = pSys->mFN_Get_SystemInfo();

        // 페이지 단위 크기가 너무 크다면 에러처리
        // 128KB 기준
        _AssertReleaseMsg(128*1024 >= pInfo->dwPageSize, "이 컴퓨터의 페이지 단위 크기가 너무 큽니다");

        // 페이지크기(상수)의 시스템 페이지크기 배율 확인
        _AssertRelease(gc_minPageUnitSize >= pInfo->dwAllocationGranularity && (gc_minPageUnitSize % pInfo->dwAllocationGranularity == 0));
->완료
//----------------------------------------------------------------
★
CMemoryBasket 통계 카운팅

        static const UINT64 sc_Debug_MaxCounting = UINT64_MAX;
        UINT64 m_cnt_Get;
        UINT64 m_cnt_Ret;
        UINT64 m_cnt_CacheMiss_from_Get_Basket;
-> 완료
//----------------------------------------------------------------
★★★★★★★★★★★★★★★★
virtualfree를 위한 로직
	virtualfree를 위한 기능
		0. 반납으로 인하여 사용카운트0인 유닛그룹은 Owner(VMEM) 의 cntFullGroud 카운팅을 확인 조건을 만족하면 확인을 시작한다
		1. 형제 유닛그룹들을 모두 순회하며
			잠금확보
			사용유닛카운팅 확인
			외부와 연결차단
			※ 실패시 중단
		2. 모든 유닛그룹이 조건을 만족한다면...
			2-1.	전역데이터 헤더 테이블 등록을 해제
				이 부분의 유지보수는 KeepingUnit_from... 함수의 내부 로직과 같게 유지해야 한다
			2-2.	VMEM의 시작주소에 대하여 virtualfree 실행, VMEM Unregister



		체크 리스트
			-	둘이상의 유닛그룹(동일한 VMEM를 부모로 둔)이 동시에 FULL 상태가 되어,
				해제 테스트 중, 형제 그룹이 잠겨 있어, 중단하고 FULL 그룹리스트에 삽입하는 경우
				(이것이 두개 이상의 스레드에서 동시에 일어나 VMEM이 해제되지 않고 FULL그룹리스트에 남아 있는 현상)


	반납 카운팅
	TDATA_VMEM::m_cntFullGroup

	어떤 유닛그룹이 full이 되어 virtualfree를 위한 절차를 밟을때,
	같은 VMEM에 속한 형제 유닛그룹들의 상태또한 테스트 해야 한다
	이때 그것을 알아보는 방법은 두가지가 있다
	(1) Full 상태 카운팅
		유닛그룹리스트(FULL)에 push/pop 할때 상태를 카운팅 한다
		이는 유닛그룹 리스트에 push/pop 할때 VMEM을 갱신해야하며
		이는 그것에 접근하는 다른 프로서세에 캐시를 무효화 시킨다
	(2) 필요시 탐색
		VMEM의 유닛그룹들을 모두 직접 체크 한다
		다른 유닛그룹들은 다른 프로세서에서 동시성으로 사용되어
		캐시로 다시 읽어올 확률이 높다
		(1)의 경우에도 결국 최종적으로는 모든 유닛그룹을 확보하기 위한
		과정을 거친다

	-> (1)을 사용한다
	(2)의 심각한 문제는 1개의 VMEM에 속하는 유닛 그룹을 사용자 alloc/free 로 인하여
	매번 FULL 상태가 되는 경우가 잦은데 이때마다 모든 유닛그룹을 순회테스트 한다는 것은
	매우 비용이 크기 때문이다



■■■■■■■■■■■■■■■■
버전 V2로 변경후 평가
	메모리 사용량 소폭 증가
	프로세서수를 넘어서는 경우의 성능저하가 기존보다 감소	TBB 동급 또는 더 빠른...
	프로세서수와 같은 수로 요구할때보다 성능은 조금 감소한다

	추가 개선을 고려하면 매우 긍정적

■■■■■■■■■■■■■■■■
1~10MB 테스트시
	과도한 용량이 할당된다

	유닛그룹이 프로세서 단위로 종속되어 공유되지 않기 때문

	-> 공유기능을 추가
	기존보다 줄어들었으나, 아직 1024요구에서 1200이 사용되는 문제가 있다

	-> 추가 원인 발견
	다중스레드에서 유닛그룹리스트가 Empty에 삽입된후 유닛이 반납되어도
	유닛그룹리스트에 대한 재평가, 재위치가 이루어지지 않았다
	Return Memory Process 에서 처리해야 한다
-> 완료
//----------------------------------------------------------------
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
TMemoryUnitsGroup_List
        void mFN_Pop(TMemoryUnitsGroup* p);
        TMemoryUnitsGroup* mFN_PopFront();
        TMemoryUnitsGroup* mFN_PopBack();
        void mFN_PushFront(TMemoryUnitsGroup* p);
        void mFN_PushBack(TMemoryUnitsGroup* p);
        void mFN_PushFront(TMemoryUnitsGroup* pF, TMemoryUnitsGroup* pL);
        void mFN_PushBack(TMemoryUnitsGroup* pF, TMemoryUnitsGroup* pL);

	TMemoryUnitsGroup 간 링크드리스트 형태이기 때문에 내부에서 수정하려는 요소(유닛그룹)을 잠그지 않으면
	데이터 무결성이 깨진다
	문제는 이 잠금 비용이 복잡하고, 비싸다는 것이다
	링크드 리스트가 아닌 다른 형태로 수정해야 한다

	이 문제는 Busy List 에 속한(MB에서 사용중인 유닛 그룹에 문제가 생긴다)
	몇 가지 방법으로 해결이 가능하다
	A계획
		UnitsGroupList , UnitsGroup 수
		연결 정보를 UnitsGroup에 양방향 리스트로 두지 않도록 수정
		유닛 그룹간 간섭이 없어짐
		UnitGroupList의 구조가 복잡해지고 동적 메모리 할당이 필요할 수 있음
	B계획
		기존 LIST 3종에서 Busy를 제거
		MB에 연결된 UnistGroup 은 LIST에 속하지 않음
		MB에서 연결이 끊어지는 경우 refcount 가 0이 되는 경우에만,
		UnitsGroupLIST에 삽입
		문제점:
			1. 유닛공유그룹을 공유하려 할때 다른 MB를 접근 하여 캐시무효가 일어나는 문제(MB::LOCK 으로 인하여)
				만약 프로그램이 할당기능만 연속으로 계속 사용하지 않는다면 큰 문제는 되지 않는다
			2. 다음의 상태에서 MB로 부터... P1 P2(프로세서) 에서 UG(유닛그룹을)...
				1	P1에서 UG refcnt-- , 0이 되어 적당 그룹리스트에 추가
				2	P2에서 UG refcnt++ , 0에서 1이 되어 이전 그룹리스트에서 제거
				3	P3에서 UG refcnt-- , 0이 되어 적당 그룹리스트에 추가
					소속 위치 일관성 문제
					1 에서 refcnt를 0으로 설정, 유닛그룹을 rest 리스트에 추가하기 위해 잠금 대기
					2 에서 끼어들어 refcnt를 1로 바꾸고 유닛그룹을 잠금성공, 소속 유닛그룹에서 제거(소속그룹이 없음)
					1 이 재개 되어 rest 리스트에 추가하려함
				해결책:  유닛그룹정보를 소속변경전에, 잠금실행, 이전상태확인, 소속유닛그룹 판단하도록
					 상태(busy/rest/full/empty)는 잠금상태에서만 수정

	※ B계획이 일단 메모리 사용량에서 우월하다

	■ 불필요한 유닛그룹 리스트(Empty)를 제거
	■ 유닛을 반납하여 유닛그룹이 FULL이 되는 경우
		유닛 관리를 리스트형태에서 하나의 주소 단위로 정리하도록
		할당요청시 가능한 연속된 주소를 리턴하도록
-> 완료
//----------------------------------------------------------------
★★★★★
TDATA_VMEM 내의
TMemoryUnitsGroup m_UnitsGroups[sc_nUnitsGroups];
현재 상태는 정적연결 2개...
	문제점이 있다
	한번에 대량의 메모리를 확장할때 단 몇개로 분할된다면.... 다수의 프로세서에서 제대로 사용할 수 없다
	이것의 해결을 위해 만약 Expansion 자체를 원하는 크기 / n 으로 분할하여 여러번 처리한다면
	상당한 오버헤드가 예상된다
만약 이것을 n개의 동적연결방법을 취한다면?
	문제는 오브젝트풀에 접근하는 경쟁이 심해진다
	또한 1...n 개로 각각의 풀에 접근하도록 처리해야하는 귀찮은 문제가 있다
	T * (1~n) 크기 오브젝트 풀 사용방법에는 다음의 방법이 마련되어 있다
	UTIL::MEM::OBJPOOLCACHE
		gFN_Alloc_from_ObjectPoolCache
		gFN_Free_from_ObjectPoolCache

	오브젝트풀에 정의된 크기들은 1024

	만약 할당된 메모리를 미래의 64코어를 예상하고 64 * 64 B 계산시
	필요량은 4KB
	이문제는 어떻게 해결할 것인가?
	기본생성 오브젝트풀 크기를 더 늘리는가?

	위 인터페이스들은 최대 1024 KB에 접근하도록 하고,
	배열등에도 사용되기 때문에
	4KB까지 유닛을 만들되 접근가능한 인터페이스를 따로 두도록 한다

	gFN_Alloc_from_ObjectPoolCache__max4KB
	gFN_Free_from_ObjectPoolCache__max4KB
-> 완료
//----------------------------------------------------------------
★
사용자에 의한 수동 메모리 예약과 관련하여
	이때 사용자는 최소 수요를 예측했다고 볼수 있다
	때문에 프로그램 종료전까지 해당 그룹(유닛그룹들의 집합)은 OS 에 Free 되어서는 안된다

	관련 인터페이스는 다음과 같다
		mFN_Reserve__from_MemorySize
		mFN_Reserve__from_Units

	다음의 플래그를 추가, ON의 경우 프로그램 실행도중 VirtualFree 과정을 수행하지 않도록 함
		TDATA_VMEM::m_bDont_VirtualFree

	※ 이는 프로그램 동작도중 VirtualFree를 수행하는 메모리풀 V2 이상급에 적용된다
	※ 이 기능은 프로그램의 생명주기가 길수록(또한 동적할당/해제가 많을수록) 큰 이익을 가져온다
		VirtualAlloc/VirtualFree , 그리고 상당한 점유율을 차지하는
		mFN_KeepingUnit_from_AllocatorS_With_Register
		mFN_KeepingUnit_from_AllocatorN_With_Register
		함수들의 호출을 억제할 수 있기때문

메모리 virtualfree 호출을 막기위한 기능
	사용자에 의해 미리 예약됨 메모리 덩어리(VMEM(n UnitsGroup))은 virtualfree 하지 않도록 수정
사용자에 의한 용량 확보 부분
	문제점은 헤더부분의 크기가 포함되어 있다는 것
	이것을 별도로 계산하여 추가하도록 해야함
	::mFN_Add_ElementSize	부분을 수정하면 해결
-> 완료
//----------------------------------------------------------------
★ MemoryBasket 객체사용에 있어 LockFree 하도록 수정
	Attach / Detach 제외
-> 완료(상당한 성능 개선)
//----------------------------------------------------------------
★★★★★★★★★★
성능 향상
	Expansion 에서 유닛간 link 부분은 테스트 1회 루프기준
	점유율을 20~25% 차지
	이부분을 감소시킬 방법
		유닛그룹에 현재주소~끝주소를 기록
		Unit PTR 이없다면 주소에서 가져 오도록
		이때 OS로부터 메모리 매핑이 일어남
			(n개를 모두 매핑하는 것보다는 나음)

		프레임 워크 예상
			UnitsGroup::PopFront

			if(m_Units.m_First)
				return m_Units.m_First;
			else if(현재주소<끝주소)
				return 현재주소, 현재주소 += 유닛크기+Alpha(큰 유닛, 작은유닛은 각각 계산 방식이 다름)

		※ 문제점
			아직 물리메모리가 매핑되지 않은 영역정보, (현재/끝)의 정보를 UnitsGroup 객체에 포함해야 하는데
			현재 64B 에서 128B로 늘어나게 된다(x64 기준)

			이 경우 작은 유닛은 1VMEM:nUnitsGroups, 유닛그룹은 최소 1페이지(64K)
			VMEM을 제외하고 계산하하더라도 관리오버헤드는 64B/64KB -> 128B/64KB
			0.1% -> 0.2%
			여기서 추가적으로 64KB를 모두 활용하지는 못하기 때문에 낭비는 더 심해진다

	수정전 현재 로직
		유닛그룹별 데이터블록헤더는 가장 첫번째것만 전역 테이블에 등록
		n번째 헤더내용 =
			작은유닛 / 큰유닛 공통
			유닛그룹의 첫번째 헤더의 내용 복제

	추가할 데이터
	TMemoryUnitsGroup 데이터 64B -> 128B 확장(x86은 가능한 64B를 사용하도록)
	x86 4B기준 16유닛(LOCK 2유닛)
		현재 주소(남은, 예약된 : 더 적합한 표현은?)		// 추가
		마지막 주소(예약된)					// 추가
		남은 페이지						// 추가

		First DataBlockHeader PTR				// 추가
		유닛크기						// 추가
		유닛타입 BOOL						// 추가

	※ 복잡해지는 문제
		사용자의 사용시점 물리메모리 매핑의 지연처리
		작은유닛
			예약단위(64KB) 별 앞부분에만 헤더4KB가 포함
		큰유닛
			n개의 유닛중 대표헤더가 등록...
			기타 헤더들은 사용시점에 초기화

	구현
		KeepingUnit_from... 의 기능중 그룹별 관리하는 모든 유닛들을 리스트로 연결하는 부분을 제거
		유닛그룹은 사용자의 메모리 요청시 m_Units에 없다면 주소를 확인하여 가져 오도록
		이때 필요하다면 헤더 등록

-> 완료 약 5%~25% 성능 향상
//----------------------------------------------------------------
★★
	기존 빠른 메모리풀 접근을 위한, g_pTable_MemoryPool (요구크기->메모리풀)에 해당되는 메모리풀의 인덱스를 포함
	각 메모리풀의 인덱스는 다른 확장 기능에 필요함
	명칭 변경 -> g_Array_QuickLink_MemoryPool
	풀 관리자내 풀 관리를 set -> array
-> 완료
//----------------------------------------------------------------
오류 수정
	메모리 유닛 할당시 문제가 발생
		유닛그룹에 유닛을 꺼낼때, 사용 유닛 카운팅이 최대보유 유닛수를 초과하는 현상

	TMemoryUnitsGroup::mFN_Sort_Units() 에서...
		FirstUnit을 설정할때 FirstUnit의 next nullptr 초기화를 하지 않은 문제
-> 완료
//----------------------------------------------------------------

★★★
	Sleep 은 낮은 우선 순위의 스레드로 스위칭 되지 않을수 있다
	SwitchToThread를 대신 사용
-> 완료
//----------------------------------------------------------------
★★★★★★★★
	오브젝트풀 공간 낭비 문제
	VirtualAlloc 할당 단위간 연결을 위한 64B 공간이 포함되며
	이것이 4KB를 차지하는 경우의 문제
	64 또는 128 정도로 관리 유닛을 별도로 둔다면 낭비를 막을 수 있다

	관리그룹은 x86 x64 각각 64B 128B
		next관리그룹
		슬롯사용카운팅
		슬롯[14]
-> 완료
//----------------------------------------------------------------
★★★★★ 기능 결함
virtualfree가 안 되고 남은 유닛
	재현방법
		무작위 크기
		n 스레드

	-> 원인 확인(원인 확인에 약 6시간 걸림)
		메모리 Expasion 에서 생성된 유닛그룹들이 전혀 쓰이지 않고
		FULL 리스트에 등록된채 프로그램이 종료된 현상

		Expansion을 요청한 코어C1의 스레드T1이 Expansion 작업도중
		다른 스레드T2가 코어C1에서 실행되면서, MB에 다른 유닛그룹을 연결,
		C? T1에서는 Expansion 마무리 작업에서 MB에 유닛그룹을 연결하려 하나
		이미 연결되어있어 실패, 이에 따라 FULL 리스트에 등록

		이때 Expansion 시작전 시점, Expansion내부 분배 시점 에서
		현재 스레드가 동작하는 프로세서가 변경되어 문제가 발생
		MB는 무잠금으로 사용하기 때문

	- 속도를 희생하지 않는 해결 방법은?
	- 해결해야 하는가?
		메모리가 부족하여 Expansion 되었기 때문에 방치해도 무관할듯
		-> 결국 사용될 것이다
		-> 문제가 되는 시나리오
			어떤 크기 단위가 프로그램 생명주기동안 어느 시점부터 전혀 사용되지 않는 경우
			이때 문제의 할당된 유닛그룹들(1 VMEM)이 상당히 큰 경우
	- 이때 낭비되는 메모리는 유닛그룹수 * 4KB
		8코어 CPU 기준 32KB

	■ 해결 방법
		CMemoryPool 에 생성된 유닛그룹들을 보관할때
		CMemoryPool::m_pExpansion_from_Basket 에 우선권을 주는 부분에서...
			다른 스레드가 이 프로세서(코어)에 끼어들어, 여유분 유닛을 가진 유닛그룹에 연결해버린 경우
			새로 생성된 유닛그룹들은 모두 유닛그룹리스트에 보관되는 현상
				이때 문제는 이들은 적어도 한번 사용자 할당요청후 해제가 되어야 virtualfree 체크를 하기 때문에 문제가 되는데
				만약, 이미 연결된 유닛그룹이 있어도 새로운 것으로 교체 해버린다면 이 문제를 피할 수 있다

	■ 해결하지 않고 보류하는 이유
		이때, OS의 물리적 메모리 연결부분이 영향을 주는데 virtualalloc을 하더라도 메모리에 접근하지 않는다면
		물리적 메모리에 연결이 되지 않은 상태(단지 주소공간을 예약했을뿐이다)
		실제 만들어진 VMEM(n개 유닛그룹)은 앞부분 헤더에 기록으로 인하여,
		n * 4KB(OS 기본 할당단위)을 차지하고 있을 뿐이다
			여기에 VMEM, 유닛그룹의 메모리는 오브젝트풀에 의해 추가적인 사용이 있다
-> 보류
//----------------------------------------------------------------
TLS 관리 방식 변경
	기존 방식은 사용자에게 불편함을 야기 하며, Core DLL을 다른 DLL 에서 사용할때 사용이 불가능 하거나
	또는 복잡한 구현을 요구 한다

	TlsGetValue TlsSetValue 를 사용한다 이 함수들은 스레드 스택에서 index 위치의 값을 빠르게 리턴한다
	TlsAlloc 사용시 리턴값(인덱스)를 확인해야 함
		실패	TLS_OUT_OF_INDEXES

	스레드 종료 신호
	DllMain에 메세지가 들어온다
	DLL_THREAD_DETACH
		스레드가 종료전에 호출함
	DLL_PROCESS_DETACH
		스레드가 DLL 연결을 해제하면서 호출함
		(스레드의 종료가 아닌 DLL 연결 해제)

	TLS를 이용하여
		유닛그룹을 독점 사용 또는 유닛그룹에서 n개의 유닛을 TLS에 확보해둔다면
		사용자는 잠금없이 빠르게 Get/Ret 가능하다
-> 완료
//----------------------------------------------------------------
추가 속성 항상 모든 유닛그룹 공유
	m_bUse_OnlyBasket_0
	사용시 프로세서캐시중 0번만 사용함
	Set ON
		0번 Basket을 제외한 나머지에 연결된 유닛그룹 모두 연결해제
	Set OFF

-> 완료
//----------------------------------------------------------------
★★★★★★★★★★★★★★★★
CMemoryUnitsGroup_List	변경
	다음의 문제가 있어 변경함
	속도, 안전성, 객체 결합도

	기존
		리스트 연결정보가 유닛그룹 prev / next 형태로 유지 하였음
		예외적 상황인, [유닛그룹]이 주체가 되어 [유닛그룹리스트]에 접근, 유닛그룹 자신을 제거하는 기능이 문제
		이것은 너무 복잡하며, 확장성이 없음
		또한 리스트에 추가/제거시, 다음의 문제가 있음
			유닛그룹B가 추가 된다고 할때...
			유닛그룹A-유닛그룹B-유닛그룹C
			A B C 그룹 모두 내부의 연결정보가 수정됨에 따라 A C는 불필요한 캐시 무효화가 일어남

	다음과 같이 수정해야
	class CMemoryUnitsGroup_List{
		struct TChunk{
			TChunk* pPrev
			TChunk* pNext
			UINT32	iSlotPop	// 가져갈 유닛 인덱스
			UINT32	iSlotPush	// 유닛이 삽입될 인덱스
			TMemoryUnitsGroup	pSlot[N] // 캐시라인의 배수 단위에서 위의 다른 멤버변수를 제외한 나머지 공간 활용
		};
		Lock;
		TChunk pFirst
		TChunk pLast
	};
	CMemoryUnitsGroup_List	Rest;
	CMemoryUnitsGroup_List	Full;

	※ 청크의 크기(캐시라인 배수)에 따른 슬롯수
	슬롯을 제외한 다른 멤버 변수 크기: x86(12)	x64(24)
		64B	128B	256B
	x86	12	28	60
	x64	5	13	29

	유닛그룹은 유닛그룹리스트에 소속시 다음의 정보를 보관해야 한다
		1. CMemoryUnitsGroup_List::TChunk*	소속 청크
		2. 청크내에 사용중인 슬롯의 인덱스	(제거시 고속 접근을 위해 필요하다)

	※ 유닛그룹으로 부터 소속 유닛그룹리스트 확인
		유닛그룹의 현재 소속상태를 확인하여 접근
		유닛그룹은 또한 청크의 주소를 접근가능하도록 기록해둔다
		추가적으로 청크내 슬롯의 인덱스를 기록
		※ 인덱스는 제거시 고속 접근을 위해 사용한다
			앞쪽 인덱스 슬롯이 빠져 나갈때 가장 뒤의 사용중인 슬롯의 유닛그룹이 빈자리로 옮겨 온다
			이때 대상 유닛그룹의 인덱스를 수정한다(잠금 없이)
			※ 문제는 발생하지 않는다
				1. 유닛그룹은 유니크 오브젝트 풀에 의해 유닛그룹들에 대해서만 사용된다
					잠금 없이 접근하는 다른 유닛그룹의 주소가 무효한 일은 없다
				2. 만약 유닛그룹의 현재 인덱스가 청크내의 슬롯에 일치 하지 않는 경우 재 탐색 하면된다
			※ 유닛그룹 리스트 내에서 제거로 인한 가장 마지막 슬롯 유닛그룹의 인덱스를 수정하는 일은
				매번 유닛그룹리스트에 삽입시 빈슬롯을 탐색하는 일보다는 값 싸다
		☆ 문제가 생기지 않기 위해서는 유닛그룹리스트를 잠그고 처리 해야 한다
	※ TChunk의 추가로 메모리 사용량 약간 추가
-> 완료
//----------------------------------------------------------------
다음의 객체는 오브젝프 풀을 적용하지 않는다
	CObjectPool_Handle<TDATA_VMEM>
	virtual memory 의 일부를 사용한다
	virtualAlloc 이후 확보한 메모리 일부를 TDATA_VMEM에 사용한다

	장점
	1. 기존 TDATA_VEMEM 오브젝트풀에 접근, 잠금 비용의 제거
	2. 할당된 메모리에서 유닛들이 사용하지 못하는 잉여공간 활용
-> 완료
//----------------------------------------------------------------
★★★★★★★★★★★★★★★★
무효해진 주소 접근 문제
	▶치명적 오류 가능성A
	이 오류는 작동도중 VirtualFree를 위한 구현에서 비롯된다
	유닛그룹리스트의 관리에 있어 VirtualFree를 시도하려는 스레드에서
	UnitsGroupList Lock
		UnitsGroup Lock
		UnitsGroup UnLock
	UnitsGroupList ULock
	위 순서가 아닌, 일단 잠그고 보는 식이기 때문에
	유닛그룹 리스트에서는 Pop, Push시에
	CPU CORE의 CACHE 에 올라와 있는 이미 무효할지도 모르는 유닛그룹의 정보를 사용하기 때문

	유닛그룹리스트내의 유닛그룹간 연결 리스트를 유닛그룹내에 두지 않도록 해야 한다
	추가적인 타입 T를 정의해야 한다
		이것은 n개의 유닛그룹을 연결한다

	또한 기존 유닛그룹내의 양방향 연걸 정보
	TMemoryUnitsGroup* m_pLink_Prev;
	TMemoryUnitsGroup* m_pLink_Next;
	는 T의 주소, T내부에서 자신을 가르키는 인덱스로 활용해야 한다

	▶치명적 오류 가능성B
	A와 같은 원인
	이 경우는 mFN_UnitsGroup_Detach_from_All_Processor 에서 비롯된다(MB에서 유닛그룹을 연결해제하는 과정)
	프로세서간 공유하는 유닛그룹을 공유해제, 제거하는 과정의 문제

	다음 메소드에서 문제가 생긴다
	TMemoryObject* CMemoryPool::mFN_Get_Memory_Process__Internal()


            auto pChunk = mb.mFN_Get_UnitsGroup();	<-1
            // 확률이 높은 순으로 처리
            if(pChunk)					<-2
            {
                pChunk->m_Lock.Lock__Busy();		<-3

	1,2,3 과정 언제든 pChunk는 다른 스레드에 의해 해제되어 무효화된 주소일수 있다
	
	만약, mb.mFN_Get_UnitsGroup(); 하는 순간 잠금을 한다면?
	mFN_UnitsGroup_Detach_from_All_Processor 또한 고려?
	유닛그룹에 접근 카운팅을 한다면?

-> 분석 : 유닛그룹 잠금장치 위험 요소
	유닛그룹을 잠근후
	유닛그룹의 참조마스크를 확인하면 디버깅 가능

	참조 마스크 수정 부분(유닛 그룹을 잠근 상태에서...)
	BOOL CMemoryBasket::mFN_Attach(TMemoryUnitsGroup* p)
	BOOL CMemoryBasket::mFN_Detach(TMemoryUnitsGroup* pCurrent)

	프로세서단위에서 연결되어 있는 유닛그룹잠금 성공후
	캐시의 유닛그룹과 주소 일치 확인
	(다른 스레드가 해제할 경우 해당 프로세서캐시에서 유닛그룹의 연결을 강제로 해제)
	(이때 프로세서캐시에는 수정된 올바른 값이 들어온다)
		문제점은 유닛그룹을 잠그려하는 시점 바로직전에 다른 스레드에 의해 해당 유닛그룹주소가 무효한 주소가 될 수 있다
		-> MB를 잠금을 걸고 사용하면 안전...
			-> 이 방법은 이전에 사용하던 느린 방법. 또한 적용을 하기 위해서는 많은 곳을 수정해야 한다
			예를 들어 MB에서 유닛그룹을 연결해제하는 경우 잠금을 거는데,
			이때 잠금 순서는 [유닛그룹],[MB] 의 역순이 되어 데드락 가능성이 있다

	-> 시나리오
		문제 발생 지점은 Get Memory Internal 부분
		T1
			Basket 에서 유닛그룹을 얻은 직후
			1. 잠금(INFINITE) : 경우에 따라 무한 잠금에 걸린다
			2. 유닛이 삭제되어 무효한 상태
		T2
			해당 주소의 유닛그룹을 소멸

	※ 문제점 정리
		CMemoryBasket (CPU 코어단위 저장소)의 무잠금 사용으로 인한 문제(이하 MB로 칭함)
			스레드A가 MB에 연결된 유닛그룹을 받아 잠금을 확보하기 바로 직전,
			다른 스레드B가 끼어들어 MB에 연결된 유닛그룹을 제거하는 경우 해당 유닛그룹은 무효한 주소,
			스레드A가 그 것을 사용하는 경우 치명적인 오류로 이어진다

-> 해결책
	- 유닛그룹은 전용 오브젝트풀에서 별도 관리한다
		(프로그램 종료전까지 소멸시키지 않는다)
		(타입단위의 유니크한 오브젝트풀 필요)
	- 유닛그룹을 삭제시 잠긴 상태로 제거(유닛그룹을 제거하는 측)
	- 사용자는 유닛그룹을 잠근후, 간단한 무효성체크를 한다(유닛크기등)
		(유닛그룹은 소멸시 무효성체크에 사용되는 변수를 무효화값으로 채운다: 대표적으로 유닛크기)
		사용자는 만약 유닛그룹이 무효하다면 다시 언락한후 더 이상 사용하지 않는다(그외 소멸처리를 하지 않는다)
		(다수의 스레드에서 아직 주소를 보유하였다면 또 다시 접근할 가능성이 있기 때문에 잠금의 동작이 가능해야 한다)

	1. 유닛그룹은 유니크 오브젝트 풀 사용
	2. 유닛그룹을 삭제시 잠긴 상태로 제거(유닛그룹을 제거하는 측)
		유닛그룹의 잠금장치위치를 유닛그룹의 시작주소로부터 최소 8B 이격시켜 유효성을 유지한다
		오브젝트풀에서 처음 8B는 관리에 사용되기 때문에
	3. 유닛그룹 사용을 위해 잠금시 INFINITE가 아닌 스핀회수 적용
	※ 다수의 스레드에서 공유된 유닛그룹의 경우 문제 발생 소지
		-> 사용하지 못해 추가 할당이 필요할 수 있다
			-> INFINITE 실패시, 유효성 확인후 재진입 하면 된다
			유효성 확인에 사용 가능한 값
			(생성자에서 초기화 하지 않는 값)
			초기화 하는 값
				컨테이너의 의 ptr, index
				유닛 사이즈
				메모리 정렬 방식
				VMEM ptr
			초기화 하지 않는 값
				유닛(F/B) ptr 이 값은 쓰래기 값으로 초기화(사용할 수 없다)
				nUnits
				nUnits Total
				State
				ReferenceMask
			-> 이미 모두 처리 하였다
				잠금 성공여부 + MB의 연결된 유닛그룹과 비교

		4. 유닛그룹을 생성 하는 측
			잠금을 획득
			처리
			잠금을 해제
		※ 유닛 그룹 생성자에 문제의 소지는 없는가?
			(0으로 채워지는 문제 등의)
			이 경우 생성자를 없에고 초기화 함수를 사용해야 한다
			-> 문제 없음
			-> 단, 유닛그룹을 사용하는 측은 다음의 확인 과정을 거쳐야함
			#1 프로세서에 연결된 유닛그룹 사용하는 경우
				1. 프로세서에서 유닛그룹 GET
				2. 유닛그룹 잠금 시도
				3. 잠금 성공유무와 관련없이
					프로세서에서 유닛그룹 GET을 다시 시도하여 만약 다르다면 무시한다
					(잠금을 성공한 경우라면 잠금해제를 한다)
			#2 기타의 경우
				1. 유닛그룹 잠금 시도
				2. 잠금 성공유무와 관련없이
					유닛그룹 상태가 무효한 상태라면 무시한다
					(잠금을 성공한 경우라면 잠금해제를 한다)
-> 완료	
//----------------------------------------------------------------
유닛그룹들에 유닛을 분배하는 부분
	기존 CMemoryPool::Keeping ...에서
	CMemoryPool_Allocator_Virtual 에서 처리하도록 수정
-> 완료
//----------------------------------------------------------------
인터페이스 기능 추가
	Reserve 계열
		기존 Reserve 함수들... 메모리를 추가
	Hint 계열 (추가기능)
		최대 할당 메모리 힌트
		(경우에 따라 좀더 메모리를 절약할 수 있음)
		다음의 처리를 함
		CMemoryPool_Allocator_Virtual::m_stats_Max_AllocatedSize
		와 비교하여 더 큰 값이라면 셋
	★★★★★
mFN_Add_MaxStorageMemorySize 을 사용하여 최대 보관크기를 적절히 추가
mFN_Set_MaxStorageMemorySize 을 사용하여 최대 보관크기를 적절히 추가
-> 완료
//----------------------------------------------------------------
VMEM , UnitsGroup 생성/삭제 방식 수정
	VMEM
		sFN_Create_VMEM(void* pVirtualAddress, size_t SizeAllocate);
		sFN_Delete_VMEM(TDATA_VMEM* pThis);
	UnitsGroup
		mFN_Build_UnitsGroups(size_t n, size_t UnitSize, BOOL _Use_Header_per_Unit);
		mFN_Destroy_UnitsGroups();

	VMEM 생성
		1. virtualalloc
		2. sFN_Create_VMEM
	VMEM 삭제
		sFN_Delete_VMEM

	유닛그룹의 생성
		1. mFN_Build_UnitsGroups
		2. CMemoryPool 내에 보관
	유닛그룹의 삭제
		1. 유닛그룹들의 모든 연결 해제(사용중단)
		2. mFN_Destroy_UnitsGroups 호출

	메모리 풀에서 VMEM을 제거 할때는
		mFN_VMEM_GiveUp
-> 완료
//----------------------------------------------------------------
VMEM 유닛 그룹 분배
	기존 방식 할당된 크기의 자동분배는 과도하게 큰 유닛그룹이 만들어질 수 있다

	유닛그룹 종류 x1 x2 x4 x8 (그룹수)
	유닛수량 / 20(변경 가능한) = 그룹수
	▶ 그룹당 분배
	nPerGroup =  유닛수 / nG
	if(유닛수 % nG)
		nPerGroup++
	nSizePerGroup = nPerGroup * UnitSize(헤더가 있으면 포함)
	▶ 유닛 반납시 그룹 인덱스 계산
	= (반납주소 - 시작주소) / (nSizePerGroup)
-> 완료
//----------------------------------------------------------------
메모리풀 속성 변경
	사이즈 S N	-> 유닛 헤더와 메모리 정렬
			m_bUse_Header_per_Unit
			OFF	기존 S
				※ 기존 유닛그룹은 VMEM-UnitsGroup[n] 에서
					각 UnitsGroup 이 모두 헤더를 하나씩 가졌으나
					VMEM 에만 가지도록 해야함
			ON	기존 N
				1 유닛에 1헤더
	VMEM의 virtual memory는 크기별로 분류 그룹화
	재활용 가능하도록 함
-> 완료
//----------------------------------------------------------------
★★★★★★★★★★★★★★★★
TLS 유닛 확보, 관리
	일정 크기 이하의 유닛단위의 메모리풀들에 대하여 적용한다
	관련 설정
	TMemoryPool_TLS_CACHE
	TMemoryPool_TLS_CACHE::TUNITS

	★★★ TLS 사용자 할당 로직
		1. TLS에 유닛이 있다면 완료
		2. 유닛 그룹에서 TLS로 n개 유닛 이동

	★★★ TLS n개 유닛 반납 로직
		_alloc를 이용 임시 슬롯을 생성
		struct TempSlot{
			TMemoryUnitsGroup* pChunk;// 반납할 목적지
			size_t* pAddress;
		}
		1. 주소순 정렬
		2. 유닛그룹 조사
		3. 같은 유닛그룹에 속하는 것 단위로 반납
		유닛그룹 인터페이스 : n개 단위 GET/RET
		UINT32 mFN_Pop(TMemoryObject** _OUT_pF, TMemoryObject** _OUT_pL, UINT32 nMaxRequire); // 리턴 : 확보한 유닛수
		void mFN_Push(TMemoryObject* pF, TMemoryObject* pL, UINT32 nUnits);

	결과
		작은 크기 단위의 메모리풀들의 단일 스레드 다중스레드 모두 반응 시간 대폭 감소
		스레드마다 약간의 메모리가 낭비될 가능성이 있음
	
-> 완료
//----------------------------------------------------------------
프로그램 종료시 메모리릭이 없음에도 FULLLIST에 유닛그룹이 남아 있는 현상
	원인
		mFN_FreeMemory_ChunkGroup 에 VMEM 소속유닛그룹들이 모두 동시에 서로 다른 스레드에서 FULL이 되어 동시 진입하는 경우
		데드락 과 같은 원리로 Free가 실패하여 종료시까지 Free 조건이 충족됨에도 FULLLIST에 유닛그룹이 남게 되는 현상
		연결 해제 기능 필요
	해결
		CMemoryPool 의 소멸자에서 처리
		(소유 객체들의 소멸자들이 호출되기 전에 처리)
		FULL LIST 에 들어있는 유닛그룹을 모두 꺼낸다
-> 완료
//----------------------------------------------------------------
★★★★★
성능 문제
	병목지점
	일부 테스트 방식(T8 64~2048) 에서 다음 부분이 점유율 40.6%
	TMemoryUnitsGroup* pUG = (TMemoryUnitsGroup*)gpFN_Array_MemoryUnitsGroup_Alloc[n]();

	->
	할당자에 캐시를 둔다면?
	1,2,4,8 종류별 n개를 저장소에 보관

	※ 현재의 n그룹 종류는 2개(VMEM 크기가 2종이기 때문)
		만약 이것을 고정한다면 이 작업은 간단해지나, 이후 리팩토링이 힘들어진다
	-> 미리 계산해두고 사용이 가능한 것
		VMEM Build UnitgGroups 에서 사용되는
			nGroup, nUnits, 그룹당 분배수
	-> UnitsGroup Alloc/Free 캐시
		n개 단위로 오브젝트 풀에 Alloc/Free
		n*2 크기의 슬롯을 마련
			필요시 오브젝트풀에서 n개를 가져와 캐시에 보관
			제거시 캐시에 먼저 보관, 가득 차면 n개를 오브젝트 풀에 반납
		위 (n*2) 슬롯이 2개가 필요
		n(4) 일때 (4*2)*2 = 16 슬롯 필요 : x64에서 2캐시라인(128) 필요
		※ ptr** 슬롯형태가 아닌 리스트 형태 관리시 발생하는 문제점
			1. 메모리레이턴시 문제발생
			2. 리스트로 관리하기 위해서는 별도 동적할당을 이용하거나
				유닛그룹 내부 공간을 이용해야 하는데 이는 선택할 수 없는 방법이다
				(유닛그룹은 해제후에도 접근할 가능성이 있기 때문에 데이터를 유지해야 한다)				
		※ 슬롯 종류는 할당단위 Small/Big 에 따라 서로 다른 캐시라인 또는 하나의 캐시라인에 모두 포함 되도록

	-> 오브젝트풀 n개 Alloc / Free 기능 추가 필요
		-> 오브젝트의 주소형태는 리스트? 또는 포인터 배열(**)
	-> CMemoryPool_Allocator_Virtual 의 기존 크기 2캐시라인(128)에 최소, 2캐시라인(128)이 추가되어야 한다
		풀종류258 * 128 = 32.25KB

	-> 진행기록
		오브젝트풀기능추가->MemoryPoolCoreV2.cpp/h 리펙토링

->완료(성능 개선됨)
//----------------------------------------------------------------
★★★★
오브젝트풀 개선
	1. Alloc/Free n개 단위 필요
	2. Expansion 시, 유닛을 미리 연결하지 않고
		예약된 주소를 맴버 변수로 두어 사용할 수 있도록
		(메모리풀의 유닛그룹과 같은 기능)
	※ Expansion 시, 상당히 긴 시간동안 블로킹되어 다수의 스레드 접근시 문제가 있기 때문에
-> 완료
//----------------------------------------------------------------
메모리풀관리자 기능 추가
	아무 메모리나 조금 해제 하여 힙메모리 확보
	Reduce_AnythingHeapMemory
	VMEM LIST CACHE를 1차 확인, 그중 하나를 해제
	(가능한 작은 것)

	이것은 매우 느린 기능이 될 것이다
	사용자가 이 함수의 의중을 잘 파악할수 있게 해야 한다
-> 완료
//----------------------------------------------------------------
메모리 비교(nSize 주소, BYTE)
	메모리풀 디버그모드에서 메모리 침범을 확인하기 위한 기능의 속도문제
	mFN_MemoryCompare 수정
	mFN_MemoryCompareSSE2 추가

	DEBUG x64 기준 테스트
	LOOP5 100001~400000 1024GB T1 TEST N
		기존		2.32
		기존코드 수정	2.16
		SSE2		2.07
		SSE2		2.065 오브젝트풀 추가 적용
-> 완료
//----------------------------------------------------------------
★★★★
성능 문제
	문제점 : 매우 많은 코어를 가진 CPU의 경우 프로세서별 저장소가 너무 많아 다음의 문제가 있음
	A 메모리 낭비 가능성
		자원이 코어수만큼 분산되는 문제
	B 속도 문제
		스레드가 동작하는 코어가 고정되어 있지 않다면, 어떤 저장소에 다수의 스레드가 접근하여(할당시는 큰 문제가 되지 않음)
		하나의 유닛그룹에 대하여 간접적인 공유가 있을 수 있음
		이는 동시에 메모리를 해제하려 할때 문제가 될 소지가 있음

	해결방법
	1. 사용자에게 선택을 제공
		스레드 단위로, 사용하는 코어를 고정
	-> 부수적 이득
		코어 캐시에 접근하는 비용을 낮출수 있다(코어수가 많을 수록 특히)
-> 완료
//----------------------------------------------------------------
★★★★★★★★★★★★★★★★★
성능 문제
	테스트 환경(64~8192 1GB T8)
	
	CMemoryPool::mFN_ExpansionMemory
		m_Lock_Pool 잠금 : 22.6%
	CMemoryPool::mFN_FreeMemory_ChunkGroup
		m_Lock_Pool 잠금 : 13%

	메모리풀 전체 잠금으로 인하여 블로킹되는 확률이 높다
	이는 동일한 메모리풀에 여러 스레드가 동시에 바쁘게 접근할때 문제가 된다

	▶ 가능한 조치
	1. 세분화 하여 잠금장치를 늘릴수는 없음(적은 스레드에서 성능 하락)
	2. 임계구역 범위 축소
		MemoryPool과 Allocator 는 잠금장치 하나를 공유하는데
		이 잠금장치 접근은 MemoryPool 에서만 사용해야 일관성이 있다
		임계구역 축소를 위해서는 관련된, Allocator 내부 함수들을
		MemoryPool 에서 직접 호출해야 하므로
		객체 결합도가 높아진다(유지보수 난이도 증가)
	
	임계구역 분석 // 임계구역 제외 가능 부분 분석
	// 임계구역 분석 CMemoryPool::mFN_ExpansionMemory
		m_pExpansion_from_Basket = &MB;
		Allocator::mFN_Expansion()
			할당크기 결정(불가능)
			Allocator::mFN_Expansion_PRIVATE
				VMEM 할당(불가능)
				VMEM Build(불가능)				
				Register VMEM(불가능)
				Register VMEM to Pool
					Pool m_stats_Units_Allocated증가(불가능)
					Pool m_pExpansion_from_Basket 에 UG1 셋(불가능)
					Pool UG Full List 에 나머지 보관 // 가능

	// 임계구역 분석 CMemoryPool::mFN_Request_Disconnect_VMEM
	MemoryPool::mFN_VMEM__UnRegister(나중에 처리해도 문제가 되지 않음)
	Allocator::mFN_VMEM_Close
		Allocator::mFN_VMEM_Destroy_UnitsGroups
		{
			유닛그룹 파괴			// 가능
			유닛그룹 메모리 반납
			VMEM 값 수정 (Allocator 에서 리스트로 VMEM을 관리하기 때문에 임계구역으로 구분)
		}
		Allocator::mFN_UnRegister_VMEM
		Allocator::m_pVMEM_CACHE__LastAccess (set)
		if(무효 == VMME_CACHE_LastAccess)
		{
			Allocator::mFN_VMEM_Delete
				Allocator::통계 (set)
				VMEM::sFN_Delete_VMEM	// 가능
		}
		else
		{
			VMME_CACHE_LastAccess->mFN_Push	// 가능
		}

	수정방법
		1. Expansion
			Expansion 성공시 Register VMEM to Pool 기능을 분할, Pool에서 처리
				m_stats_Units_Allocated증가
				m_pExpansion_from_Basket 에 UG1 셋(불가능)
				[잠금 해제]
				UG Full List에 나머지 보관
		-> 완료
		2. Pool::mFN_Request_Disconnect_VMEM
			유닛그룹 파괴(파괴전 전 처리 확인)
			전역 헤더 테이블에서 등록 해제
			VMEM 값 수정
			[잠금]
			유닛그룹 메모리 반납
			VMEM 값 수정
			Allocator::mFN_UnRegister_VMEM
			Allocator::m_pVMEM_CACHE__LastAccess (set)
			if(무효 == VMME_CACHE_LastAccess)
			{
				Allocator::mFN_VMEM_Delete
					Allocator::통계 (set)
					VMEM::sFN_Delete_VMEM
			}
			else
			{
				VMME_CACHE_LastAccess 주소를 Pool을 지역변수로 전달
			}
			[잠금 해제]
			VMME_CACHE_LastAccess->mFN_Push
		-> 완료
-> 완료
//----------------------------------------------------------------
★★★★
성능 문제
	CMemoryPool::mFN_Get_Memory_Process__Internal
		m_Index_ThisPool < TMemoryPool_TLS_CACHE::c_Num_ExclusiveUnitsSlot
		이 비교가 T1에서 0.5% 점유율 차지 BOOL로 변경 가능
	-> 완료
	CMemoryPool_Manager::sFN_Get_DataBlockHeader_fromPointerQ
		주소로부터 헤더를 구하는 작업 T1 점유율 4.1%
		goto문에 의해 최적화가 되지 않을 수 있음
		pHS 위치를 미리 계산하도록(const* ptr)
		또한, 무효할지도 모르는 pHS를 prefetch할 수 있다면?
	-> 실패(효과 없음)
	메모리풀 관리자에 의해 메모리풀 접근 부분
		Get_MemoryPool	점유율1%
		TLS 적용시 풀에 접근하지 않고도 캐시를 확인하면 된다
		-> 복잡도 상승 메모리풀 내부 Get Memroy Internal static 필요
		-> 메모리풀 ON/OFF 기능이 문제
	TLS 적용되는 메모리 UnFill 점유율 15.2%(T1 기준)(더 많은 스레드도 비중은 높다)
		이중 sort 8%
		-> sort 단위 객체 내부 pUG 를 분리하여 다른 배열로
	-> 완료(효과 있음)
-> 완료
//----------------------------------------------------------------
★★★★★★★★
성능 문제 : TLS 할당/반납 로직에 수요 계산/적용
	TLS 를 이용시 유닛 Fill /Unfill 시
	유닛수량이 너무 적어서는 안된다

	1. 처리에 기본 비용이 적지않게 들어감
	2. 잠금비용보다 이익이 될정도의 수량을 적용해야...
	3. 단위가 너무 큰 경우, 사용되지 못하고 낭비될 가능성이 있음

	TEST...
	T1 8~16
	처리수량	4	16	24	32	64	128	256	512
	소모시간	27	16	15.5	16	14.65	15.056	14.83	15.61

	TMemoryPool_TLS_CACHE::TUNITS 에 설정값 조절
-> 완료
//----------------------------------------------------------------
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
중대한 문제점 #1
	이 문제는 메모리풀이 256KB 단위로 1헤더를 사용할때
	첫번째 헤더에 접근하려 할때 문제가 발생한다

	이때 256KB에 정렬된 시작주소를 이용하는데,
	VirtualAlloc은 예약단위 64KB에 정렬된 주소를 리턴하기 때문에 위치가 어긋날 가능성이 매우 높다
	방법#1
		VirtualAlloc 의 예약단위를 64KB -> 256KB로 바꿀 방법이 있는가?
		-> 불가능(XP 버전에서 관련 함수를 찾을 수 없다)
	방법#2
		만약, VirtualAlloc으로 예약한 것을 둘로 분할하여 예약 취소가 가능하다면?
		이때 실제 필요한 크기보다 더 많은 크기를 예약해야 한다
		정렬단위 256KB를 기준으로 한다면 OS가 리턴하는 시작 주소는
		0 64KB 128KB 192KB 256KB
		이중 0, 256KB 는 정렬된것 이기때문에 OK
		예약시 + 192KB를 추가
		예약된 주소들에서 앞, 뒤의 정렬되지 않은 주소를 예약 해제
		남은 주소를 커밋

		-> 실패(테스트 결과)
		Resereve 했던것은 통째로 Release 해야 함
	방법#3
		_aligned_malloc 을 사용한다면?
		추가되는 비용이 크지 않은가?

		-> 실패
		정렬단위 192KB에서 에러 발생
	방법#4
		256KB VMEM에 한하여 n개씩 묶어 한번에 예약한다면....
		앞뒤 여분들(192KB)를 포함하여 주소를 예약
		정렬되지 않은 여분주소들은 오브젝트 풀에 사용하도록 공유
		나머지 공간들을 사용
		복잡도가 올라가는 문제가 있다

	
	-> 방법#4가 가장 유력
		※ 남는 64KB 단위 여분들(합 192KB)을 오브젝트 풀과 공유 문제
			호환 문제도 있지만 오브젝트풀은 메모리풀보다 나중에 파괴되는 문제가 있다
			복잡도가 매우 올라간다
		※ 예약후, 각 단위의 관리
		※ 예약주소 Release 시, 할당단위 조각들을 모두 확인해야 하는 문제

		TDATA_VMEM 에 2번째 캐시라인에 남는 공간 7슬롯을 활용
		VMEM n(80개 유력)개를 예약한 관리객체에 접근할 방법 제공
		대상 관리 객체의 관리는 어디서?
		예약한 거대 주소는 종료전에 예약해제 가능하도록?
			-> x86에서 주소 단편화 가능성
		만약 프로그램 종료직전에만 예약해제한다면
			-> 적용되는 풀 외에 다른 풀과, 기타 메모리 할당자에서
			사용할수 있는 주소 공간 부족 가능성(x86)
		여분공간(192KB)의 활용 문제
			-> 64KB는 예약단위 데이터들의 관리 객체로써 이용 가능
			단 64KB 모두 활용하지는 않기 때문에 약간의 낭비
			-> 나머지 128KB의 활용
				오브젝트풀에 전달
				발생가능한 문제점
				1. 종료시점 문제
					오브젝트 풀이 먼저 종료되어야 한다
					메모리 주소 해제는 별도 관리 객체에서 해야 하기 때문
				2. 오브젝트풀 내에서 관리 문제
					오브젝트풀내 최적화가 이루어졌기 때문에
					64KB 단위 모두 오브젝트 공간으로 활용할 수도 있음
					-> 추가 메모리 요구 없이 64KB의 관리타입과 관리객체에 접근할 방법 필요
				

		방식을 응용하여 256KB 외 정렬을 필요로 하지 않는
		다른 기능에도 예약/커밋을 분리 사용?
			-> 마찬가지로 x86에서 주소 단편화 가능성

	관련 정보
	1. 메모리풀 에약단위 계산.ods
	2. CVMEM_ReservedMemory_Manager
-> 완료
//----------------------------------------------------------------
//----------------------------------------------------------------
//----------------------------------------------------------------
//----------------------------------------------------------------

